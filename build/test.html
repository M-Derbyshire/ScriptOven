<!DOCTYPE html>
<html lang="en">
    <head>
		<meta charset="utf-8">
		<title>Cephalopod - Text Manipulation Tool</title>
		<style>
			body {
	background: #20002c;
	color: #c2c503;
	font-family: Arial, Helvetica, sans-serif;
}

a {
	color: #009191;
}

a:hover {
	color: #007979;
}

header, main, footer {
	border: 1px solid #989b04;
	border-radius: 0.5em;
	margin: 0.5em auto;
	padding: 0.5em;
}

footer p {
	margin: 0.5em auto;
	font-size: larger;
}

#profileLinksList {
	list-style-type: none;
	padding-left: 0.5em;
	margin: 0.5em auto;
}

main label {
	font-weight: bold;
}

main div {
	margin: 0.25em auto;
}

/* Overwrite the above for 1st level of divs */
main > div {
	margin: 1em auto;
	border: 1px solid #5a5c04;
	border-radius: 0.5em;
	padding: 0.5em 1em;
}

main > div > h2 {
	margin: 0.75em auto;
}

main textarea {
	width: 100%;
	height: 20em;
	margin: 0.5em 0;
	resize: none;
	background: #66008b;
	border: 1px solid #5a5c04;
	color: #b8b802;
}

main textarea:focus {
	outline: none;
}

#runButtonSection {
	padding: 1em;
	background: #01294b;
}

#runButtonSection button {
	font-size: x-large;
}

#downloadFileNameInput {
	max-width: 100%;
}


		</style>
		<script id="dynamicScript"></script>
	</head>
	<body>
		
		<header>
			<h1>Cephalopod</h1>
		</header>
		
		<main>
			<div id="scriptUploadSection">
				<label for="scriptFileInput">Script file to use: </label>
				<input type="file" id="scriptFileInput" />
			</div>
			
			<div id="inTextSection">
				<h2>Function Input</h2>
				<textarea id="inTextInput" wrap="off">Enter the text to be passed to the function here (Or upload a file with the button below).</textarea>
				<div id="inTextFileUploadSection">
					<input type="file" id="inTextFileInput" />
				</div>
			</div>
			
			<div id="runButtonSection">
				<button id="runFunctionButton">Run Function</button>
			</div>
			
			<div id="outTextSection">
				<h2>Function Output</h2>
				<textarea id="outTextOuput" wrap="off" readonly>Results will be outputted here.</textarea>
				
				<!-- The action for the below form will be set to the download link, 
					whenever the out-text changes -->
				<!-- The file name of the download will be changed on keyup -->
				<input type="text" id="downloadFileNameInput" value="File Name" />
				<a id="outTextDownloadLink" download="generated_text.txt">
					<!-- The button should be enabled when the main function is run -->
					<button disabled id="outTextDownloadButton">Download Output</button>
				</a>
			</div>
		</main>
		
		<footer>
			<p>Developed by Matthew Derbyshire</p>
			<ul id="profileLinksList">
				<li><a id="twitterLink" target="_blank" href="https://twitter.com/mattdarbs">My Twitter</a></li>
				<li><a id="githubLink" target="_blank" href="https://github.com/M-Derbyshire">My GitHub</a></li>
			</ul>
		</footer>
		
		
		<script id="standardScripts">
			//A keyup event for when the download filename is changed.
//This will change the outTextDownloadLink download filename.
//Better to use keyup, than onchange, to be sure that the
//filename is always updated correctly, if focus is only lost
//by clicking on the download button.
function downloadFilenameInputKeyUp(e)
{
	const downloadFileNameInput = e.target;
	const outTextDownloadLink = document.getElementById("outTextDownloadLink");
	const outTextDownloadButton = document.getElementById("outTextDownloadButton");
	
	outTextDownloadLink.download = downloadFileNameInput.value;
	setDownloadButtonDisabledStatus();
}

document.getElementById("downloadFileNameInput").onkeyup = downloadFilenameInputKeyUp;

//The event listener for the in-text file upload
function inTextFileInputEventListener(e)
{
	const fileInput = e.target;
	const inTextArea = document.getElementById("inTextInput");
	
	//Get the file text and start the process
	const fileReader = new FileReader();
	fileReader.onload = function(fileReadEvent)
	{
		try
		{
			inTextArea.value = fileReadEvent.target.result;
		}
		catch(err)
		{
			handleError(err);
		}
	};
	fileReader.readAsText(fileInput.files[0]);
}

document.getElementById("inTextFileInput").onchange = inTextFileInputEventListener;

// Will run when the Run Function button is clicked
function runButtonOnClick(e)
{
	const scriptFileInput = document.getElementById("scriptFileInput");
	const inTextInput = document.getElementById("inTextInput");
	const outTextOutput = document.getElementById("outTextOuput");
	
	if(scriptFileInput.files.length === 0)
	{
		handleError("No script has been selected.");
		return;
	}
	
	//Get the file text and start the process
	const fileReader = new FileReader();
	fileReader.addEventListener('load', (fileReadEvent) => {
		try
		{
			runFunctionOnInputText(fileReadEvent.target.result);
		}
		catch(err)
		{
			handleError(err);
		}
	});
	fileReader.readAsText(scriptFileInput.files[0]);
}

document.getElementById("runFunctionButton").onclick = runButtonOnClick;



//Defines the way that general errors will be handled
function handleError(errorText)
{
	alert("Error: " + errorText);
}

//Converts a line from a csv file into an array of string values.
//When reading this code, think of the below example line:
//*******************************************************
// test,"test","te,st","",,"te""st",test
//*******************************************************

function csvLineToStringArray(line)
{
	let result = [];
	let currentString = "";
	let withinQuotes = false; //Is the current character within outer quotes (Don't include inner escaped quotes)?
	
	for(let i = 0; i < line.length; i++)
	{
		//Should we move to the next value?
		//(in-case this changes in the future, we'll keep checking that we're not at the end of the line
		//in the later conditionals, even though it's tested here)
		if((line[i] === "," && !withinQuotes) || i === line.length - 1)
		{
			//If this was triggered because it's the end of the line, we
			//also want to push this char onto the current string (if not, a 
			//comma triggered it, and we can ignore that).
			if(i === line.length - 1) currentString += line[i];
			
			result.push(currentString);
			currentString = "";
		}
		//entering or leaving the outer-quotes of a field
		//(need to ignore escaped quote chars)
		else if(line[i] === '"' && (!withinQuotes || 
			(i === line.length - 1 || line[i+1] !== '"'))) 
		{
			withinQuotes = !withinQuotes
		}
		// If reaching an escaped double-quote, just record one and skip the other
		else if(withinQuotes && line[i] === '"' && i !== line.length - 1 && line[i+1] === '"')
		{
			currentString += '"';
			i++;
		}
		//Finally, just add the current character to the current string value
		else
		{
			currentString += line[i];
		}
	}
	
	return result;
}

//A test case for if you change the above function
// console.log(csvLineToStringArray('test,"test","te,st","",,"te""st",test'));

// Takes an array of strings (each one being a line of CSV data).

// Optionally, can also take an array of strings to be treated as the
//column headers. If the headers array is not provided, the first line
//of the CSV array will be used as the headers instead.

// This will return an array of objects, where the property names are
//the column headers, and the data is mapped to the correct properties.
function csvToObjectsArray(csvLines, headers = [])
{
	//If no headers are explicitly provided, we use the first row
	if(headers.length === 0)
	{
		headers = csvLineToStringArray(csvLines.shift());
	}
	
	//Now we convert the rest of the lines into objects
	let result = [];
	let currentLineArray = [];
	
	for(let lineIter = 0; lineIter < csvLines.length; lineIter++)
	{
		currentLineArray = csvLineToStringArray(csvLines[lineIter]);
		result[lineIter] = {};
		
		for(let propertyIter = 0; propertyIter < headers.length; propertyIter++)
		{
			result[lineIter][headers[propertyIter]] = currentLineArray[propertyIter];
		}
	}
	
	return result;
}



// Takes a string (with multiple lines), and returns an array where
//each line is an item.
function stringToLineArray(stringToSplit)
{
	return stringToSplit.split(/\r?\n/);
}





//Tests that the script text contains a main function, and it has
//the correct amount of parameters
function mainFunctionDefinitionIsCorrect(scriptText)
{
	return /main\([^,]*\)/.test(scriptText);
}

//Populates the dynamicScript element with the given script text
function populateDynamicScript(scriptText)
{
	//If the user had selected a different script first, then just setting
	//the text of the script tag won't change to the newer main() function. 
	//We need to actually replace the script element.
	const dynamicScriptElementID = "dynamicScript";
	
	const currentDynamicScript = document.getElementById(dynamicScriptElementID);
	const newDynamicScript = document.createElement('script');
	newDynamicScript.id = dynamicScriptElementID;
	newDynamicScript.text = scriptText;
	
	currentDynamicScript.parentNode.replaceChild(newDynamicScript, currentDynamicScript);
}

//Called by the FileReader callback (in runButtonOnClick()). Takes the 
//text from the script file.
function runFunctionOnInputText(functionText)
{
	//Does the given script text contain a "main" function that takes only 1 parameter?
	if(!mainFunctionDefinitionIsCorrect(functionText))
	{
		handleError('The uploaded script does not contain a "main" function (or the given function does not accept only 1 parameter).');
		return;
	}
	
	const inTextInput = document.getElementById("inTextInput");
	const outTextOuput = document.getElementById("outTextOuput");
	
	try 
	{
		populateDynamicScript(functionText);
		const resultText = main(inTextInput.value);
		
		//normal equality, so will also catch undefined
		if(typeof resultText !== "string")
		{
			handleError('The given "main" function ran, but it did not return a valid string value.');
			return;
		}
		
		outTextOuput.value = resultText;
		
		//Need to update the download URL on the out-text download link
		updateOutTextDownloadURL();
	} 
	catch (err) 
	{
		handleError(err);
		return;
	}
}

//Will check if the out-text download button should be enabled, and
//then set it accordingly
function setDownloadButtonDisabledStatus()
{
	const downloadFileNameInput = document.getElementById("downloadFileNameInput");
	const outTextDownloadLink = document.getElementById("outTextDownloadLink");
	const outTextDownloadButton = document.getElementById("outTextDownloadButton");
	
	if(outTextDownloadLink.hasAttribute("href") && downloadFileNameInput.value !== "")
	{
		outTextDownloadButton.disabled = false;
	}
	else
	{
		outTextDownloadButton.disabled = true;
	}
}

//Set the URL on the download link for the out-text
function updateOutTextDownloadURL()
{
	// See https://shinglyu.com/web/2019/02/09/js_download_as_file.html
	
	const outTextArea = document.getElementById("outTextOuput");
	const outTextDownloadLink = document.getElementById("outTextDownloadLink");
	
	const dataForDownload = new Blob([outTextArea.value], {type: "text/plain"});
	
	// We want to delete the last URL. If the user is working with a lot of
	//data, and they're working through multiple files, we don't want to keep
	//all of this in memory.
	if(outTextDownloadLink.hasAttribute("href"))
	{
		window.URL.revokeObjectURL(outTextDownloadLink.href);
	}
	
	const downloadURL = window.URL.createObjectURL(dataForDownload);
	
	outTextDownloadLink.href = downloadURL;
	setDownloadButtonDisabledStatus();
}


		</script>
	</body>
</html>